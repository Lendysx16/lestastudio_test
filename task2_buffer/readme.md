# Циклический буфер

Сама структура представляет из себя адаптер очереди фиксированной длины с операциями **push(T element)** *(добавляет элемент в конец буфера)* и **T pop()** *(вернуть элемент из начала буфера и удалить его)*. Если происходит переполнение буфера, то начинают перезаписываться элементы с начала, а указатель на первый объект перемещается на следующий.


### Реализация через односвязный список

В плюсы можно отметить удобство написания самой структуры - так как каждый элемент буфера хранит указатель на следующий объект, то данные представляются линейно друг за другом, поэтому гарантированно первый элемент на удаление будет находиться в начале, а последний в конце. 
Также такой вариант позволяет пользоваться итераторами, чтобы посмотреть содержимое буфера без удаления объектов.
В моей реализации список при иницализации не создает сразу фиксированный количество узлов в памяти, а добавляет их по мере заполнения буфера. Таким образом, не появляется проблемы, когда невозможно отличить пустой элемент от нулевого, и новый узел в очереди не будет указывать на последний *(новые элементы всегда добавляются в конец)*. Но при этом при удалении и переполнении приходится добавлять новые узлы вместо того, чтобы перезаписывать данные в уже существующем, на что уходит дополнительное время.
При необходимости буфер можно легко расширить до опредленного размера. Функция **expand(int size)** будет лишь менять поле **capacity**, переписывать весь существующий список не требуется.


### Через одномерный массив

Здесь же наоборот, при инициализации выделяется память на массив определенной длины. Так как невозможно отличить использованную ячейку от неиспользованной, то нужно хранить указатели на начало массива, конец массива, последний добавленный элемент, элемент на удаление. Зато при такой реализации, не нужно каждый раз выделять память для новых объектов, они будут перезаписывать старые. Из-за этого такой вариант будет работать быстрее, но возникают трудности при работе с указатели при написании структуры - важно не попасть на чужой участок памяти, чтобы не перезаписать данные другой программы и не потерять свои.
